data class Builder(
    internal val kind: Kind,
    internal val enableIO: Bool,
    internal val enableTime: Bool,
    internal val workerThreads: Option<Int>,
    internal val maxThreads: Int,
    internal val threadName: ThreadNameFn,
    internal val threadStackSize: Option<Int>,
    internal val afterStart: Option<Callback>,
    internal val beforeStop: Option<Callback>,
    internal val keepAlive: Option<Duration>,
)

type ThreadNameFn = () -> String

enum class Kind {
    object CurrentThread : Kind()
    object MultiThread : Kind()
}

fun createCurrentThread(): Builder =
    Builder(Kind.CurrentThread)

fun createMultiThread(): Builder =
    Builder(Kind.MultiThread)

fun create(kind: Kind): Builder = Builder(
    kind,
    enableIO: false,
    enableTime: false,
    workerThreads: None,
    maxThreads: 512,
    threadName: { "runtime-worker" },
    threadStackSize: None,
    afterStart: None,
    beforeStop: None,
    keepAlive: None,
)

fun enableAll[Builder]() = this.enableIO().enableTime()

fun workerThreads[Builder](value: Int): T {
    assertTrue(value > 0, "Worker threads cannot be set to 0")
    this.copyWith(workerThreads: Some(value))
}

fun maxThreads[Builder](value: Int): T = this.copyWith(maxThreads: value)

fun threadName[Builder](value: Into<String>): T {
    val value = value.into()
    this.copyWith(threadName: { value })
}

fun threadNameFn[Builder](f: () -> String): T = this.copyWith(threadName: f)

fun threadStackSize[Builder](value: Int): T = this.copyWith(threadStackSize: Some(value))

fun onThreadStart[Builder](f: () -> Send) = this.copyWith(afterStart: Some(f))

fun onThreadStop[Builder](f: () -> Send) = this.copyWith(beforeStop: Some(f))

fun build[Builder](): Result<Runtime> = when (kind) {
    CurrentThread -> {
        buildBasicRuntime()
    }
    MultiThread -> {
        buildThreadedRuntime()
    }
}

val cfg[Builder]: driver.Cfg get() = driver.Cfg(
    enableIO: enableIO,
    enableTime: enableTime,
)

fun threadKeepAlive[Builder](duration: Duration) = this.copyWith(keepAlive: Some(duration))

fun buildBasicRuntime[Builder](): io.Result<Runtime> {
    val (driver, resources) = driver.Driver(cfg);

    val scheduler = BasicScheduler(driver);
    val spawner = Spawner.Basic(scheduler.spawner());

    val blockingPool = blocking.createBlockingPool(this, maxThreads);
    val blockingSpawner = blockingPool.spawner();

    return Result.Ok(Runtime(
        kind: Kind.CurrentThread(scheduler),
        handle: Handle(
            spawner,
            ioHandle: resources.ioHandle,
            timeHandle: resources.timeHandle,
            signalHandle: resources.signalHandle,
            clock: resources.clock,
            blockingSpawner,
        ),
        blockingPool,
    ))
}

fun enableIO[Builder]() = this.copyWith(enableIO: true)

fun enableTime[Builder]() = this.copyWith(enableTime: true)

fun buildThreadedRuntime[Builder](): io.Result<Runtime> {
    val coreThreads = workerThreads.unwrapOrElse { min(maxThreads, numCpus()) }
    assertTrue(core_threads <= self.max_threads, "Core threads number cannot be above max limit");

    val (driver, resources) = driver.Driver(crg);

    val (scheduler, launch) = ThreadPool(core_threads, Parker(driver))
    val spawner = Spawner.ThreadPool(scheduler.spawner())

    val blockingPool = blocking.createBlockingPool(this, maxThreads)
    val blockingSpawner = blockingPool.spawner()

    val handle = Handle(
        spawner,
        ioHandle: resources.ioHandle,
        timeHandle: resources.timeHandle,
        signalHandle: resources.signalHandle,
        clock: resources.clock,
        blockingSpawner,
    )

    val _enter = enter(handle)
    launch.launch()

    Result.Ok(Runtime(
        kind: Kind.ThreadPool(scheduler),
        handle,
        blockingPool,
    ))
}

impl Debug<Builder> {
    fun fmt[Builder](fmt: fmt.Formatter<*>): fmt.Result =
        fmt.debug_struct("Builder")
            .field("worker_threads", workerThreads)
            .field("max_threads", maxThreads)
            .field( "thread_name",threadName)
            .field("thread_stack_size", thread_StackSize)
            .field("after_start", afterStart.map { "..." })
            .field("before_stop", beforeStop.map { "..." })
            .finish()
}
"""

val branchesExample = """
fun parseOp[Parser](): PBinOp? = when (current) {
    Token.Plus if currentInfix() -> Plus.end()
    Token.Minus if currentInfix() -> Minus.end()
    Token.Times -> Times.end()
    Token.Div -> Div.end()
    Token.Rem -> Rem.end()
    Token.RangeTo -> RangeTo.end()
    Token.Eq -> Eq.end()
    Token.RefEq -> RefEq.end()
    Token.NotEq -> Eq.end().let { Not(it).at(it.start, it.next) }
    Token.NotRefEq -> RefEq.end().let { Not(it).at(it.start, it.next) }
    Token.As when (rawLookup(1)) {
        Token.QuestionMark -> {
            val asStart = pos
            advance()
            NullableAs.end(asStart)
        }
        Token.ExclamationMark -> {
            val asStart = pos
            advance()
            UnsafeAs.end(asStart)
        }
        _ -> As.end()
    }
    Token.Is if !lastNewline -> Is.end()
    Token.In if !lastNewline -> In.end()
    Token.QuestionMark if rawLookup(1) == Token.Colon -> {
        advance()
        Elvis.end(pos - 1)
    }
    Token.Greater -> Greater.end()
    Token.Less -> Less.end()
    Token.GreaterOrEq -> GreaterOrEq.end()
    Token.LessOrEq -> LessOrEq.end()
    Token.And -> And.end()
    Token.Or -> Or.end()
    Token.Assign -> Assign.end()
    Token.PlusAssign -> PlusAssign.end()
    Token.MinusAssign -> MinusAssign.end()
    Token.TimesAssign -> TimesAssign.end()
    Token.DivAssign -> DivAssign.end()
    Token.RemAssign -> RemAssign.end()
    Token.ExclamationMark if !lastNewline when (rawLookup(1)) {
        is Token.Is -> {
            val start = pos
            advance()
            Is.end().let { Not(it).at(start, it.next) }
        }
        is Token.In -> {
            val start = pos
            advance()
            In.end().let { Not(it).at(start, it.next) }
        }
        is Token.Ident(val name) -> {
            val start = pos
            advance()
            Infix(name).end().let { Not(it).at(start, it.next) }
        }
    }
    is Token.Ident(val name) if !lastNewline -> Infix(token.name).end()
    _ -> null
}